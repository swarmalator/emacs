module ConeChaos where

import Data.List
import Graphics.Gloss
import GHC.Float
import Vectors
import CubicSolver

type Billiard a = [a]
type Transform a = ([a] -> [a])
type System = (Billiard Float, [Transform Float])

-- MATRICES
{-
(Gravity in x,y,z...)
|  1  0  0  t  0  0  |     |    0    |
|  0  1  0  0  t  0  |     |    0    |
|  0  0  1  0  0  t  |     | -.5gt^2 |
|  0  0  0  1  0  0  |  +  |    0    |
|  0  0  0  0  1  0  |     |    0    |
|  0  0  0  0  0  1  |     |    0    |

-}


transfer :: Float -> Float -> Billiard Float -> Billiard Float
transfer g t state = m #\* state \+ b 
  where b = [0, 0, (-1/2)*g*t^2, 0, 0, 0]
        m = transpose [[1,0,0,t,0,0]
                      ,[0,1,0,0,t,0]
                      ,[0,0,1,0,0,t]
                      ,[0,0,0,1,0,0]
                      ,[0,0,0,0,1,0]
                      ,[0,0,0,0,0,1]]
        
impact :: Float -> Billiard Float -> Billiard Float
impact a state = pos ++ (doStuff vel)
  where (pos, vel) = splitAt 3 state
        
        



{-
main :: IO ()
main = simulate displayMode bgColor stepsPerSec fullModel picFunc stepFunc
  where
    displayMode = InWindow "Cone Chaos" (500,500) (50,20)
    bgColor = white
    stepsPerSec = 1
    initBil = ((0.6, 0, 0), (1, 0.5, 1))
    initModel = (((0.0, pi / 5, 3), initBil), [])
    fullModel = (iterate (updateData 0.01) initModel)!!1000
    picFunc = (translate (-100) (-100)).(picModel 300)
    stepFunc = \vs t d -> d --updateData

picModel :: Float -> Data -> Picture
picModel h (((tp,theta,g), ((z,t,t'),(u,phi,vz))), path) = Pictures $ wedge:trace:[]
  where
    d = 5
    w = h * tan theta
    trace = Color red $ scale h h $ Line path
    wedge = Color black $ Polygon $ (0, 0):(w, h):(w, -d):(-d, -d):(-d, h):(0, h):[]    
--    bil = Color blue $ translate (z * w) (z * h) $ ThickCircle (d/2) d
--    time = translate 0 (-120) $ scale (1/5) (1/5) $ Text (show (z,t'))

-- square (x,y,z) = x^2 + y^2 + z^2

updateData :: Float -> Data -> Data
updateData dt d@(((tm,theta,g), ((z,tn,t'), (u, phi, vz))), path) = (updateModel dt (fst d), (x, y):path)
  where
    t = if (tm+dt > t') then t' - tn else (tm+dt - tn)
    p = z * tan theta
    x = sqrt $ u^2 * t^2 - 2 * t * u * p * cos phi + p^2
    y = z + vz * t - (1/2) * g * t^2
    
updateModel :: Float -> Model -> Model
updateModel dt ((t, theta, g), bil) = (params, updateBil params bil)
  where params = (t+dt, theta, g)

impactTime :: Triple -> Billiard -> Float
impactTime (_, theta, g) ((z, _, _), (u, phi, vz)) = cubicRoot a b c d
  where 
    a = g^2 / 4
    b = -g * vz
    c = vz^2 - g * z - (u / tan theta)^2
    d = 2 * z * (vz + (u * cos phi / tan theta))

updateBil :: Triple -> Billiard -> Billiard
updateBil p@(tm, _, _) b@((_, t, t'), _) | tm > t' = updateBil p (stepBil p b)
                                         | otherwise = b

stepBil :: Triple -> Billiard -> Billiard
stepBil p@(tm, _, g) b@((z, t, t'), (u, phi, vz)) = bounce p ((z', t', t'), (u', phi', v'z))
  where
    tau = t' - t
    z' = z + vz * tau - (1/2) * g * tau^2
    u' = u
    phi' = pi - (asin $ (z/z') * sin phi)
    v'z = vz - g * tau

bounce :: Triple -> Billiard -> Billiard
bounce p@(_, theta, _) ((z, t, _), vel) = ((z, t, t'), vel')
   where
    bil = ((z, 0, 0), vel')
    vel' = reflect theta vel
    t' = t + impactTime p bil

reflect :: Float -> Triple -> Triple
reflect theta (u, phi, vz) = (u', phi', v'z)
  where
    u' = sqrt (v'p^2 + v't^2)
    phi' = atan (v't/v'p)
    v'z = vr * cos theta - vn * sin theta
    v'p = -vr * sin theta - vn * cos theta
    v't = vt
    vr = vz * cos theta - u * cos phi * sin theta
    vn = vz * sin theta + u * cos phi * cos theta
    vt = u * sin phi

-}
