module Vectors where

import Data.List

type Vec3 a = [a]
type Mtx3 a = [Vec3 a]

unitx :: (Num a) => Vec3 a
unitx = [1,0,0]

unity :: (Num a) => Vec3 a
unity = [0,1,0]

unitz :: (Num a) => Vec3 a
unitz = [0,0,1]

(\+) :: (Num a) => Vec3 a -> Vec3 a -> Vec3 a
(\+) = zipWith (+)

(\-) :: (Num a) => Vec3 a -> Vec3 a -> Vec3 a
(\-) = zipWith (-)

(\*) :: (Num a) => Vec3 a -> Vec3 a -> Vec3 a
(a:b:[c]) \* (d:e:[f]) = (b*f-c*e):(c*d-a*f):(a*e-b*d):[]
(a:[b]) \* (d:[e]) = [a*e-b*d]
_ \* _ = [undefined]

(\.) :: (Num a) => Vec3 a -> Vec3 a -> a
v1 \. v2 = sum $ zipWith (*) v1 v2

(*\) :: (Num a) => a -> Vec3 a -> Vec3 a
x *\ v = map (*x) v

(\\*) :: (Num a) => Mtx3 a -> Vec3 a -> Vec3 a
vs \\* v = map (\. v) (transpose vs)

(\\**) :: (Num a) => Mtx3 a -> Mtx3 a -> Mtx3 a
m1 \\** m2 = map (m1 \\*) m2
  
mag :: (Floating a) => Vec3 a -> a
mag v = sqrt (v \. v)

dir :: (Floating a) => Vec3 a -> Vec3 a
dir v = (1 / mag v) *\ v

ang :: (Floating a) => Vec3 a -> Vec3 a -> a
ang v1 v2 = acos $ (v1 \. v2) / (mag v1 * mag v2)

proj :: (Floating a) => Vec3 a -> Vec3 a -> Vec3 a
proj v1 v2 = (v1 \. v2 / v1 \. v1) *\ dir v1

perp :: (Floating a) => Vec3 a -> Vec3 a -> Vec3 a
perp v1 v2 = v2 \- proj v1 v2

fromPolar :: (Floating a) => [a] -> [a]
fromPolar (r:t:zs) = (r*cos t):(r*sin t):zs
fromPolar _ = [undefined]

toPolar :: (RealFloat a) => [a] -> [a]
toPolar v@(_:_:xs) = (mag $ take 2 v):(getPhi v):xs
toPolar _ = [undefined]

fromSpher :: (Floating a) => [a] -> [a]
fromSpher (r:t:p:xs) = (r*sin t*cos p):(r*sin t*sin p):(r*cos t):xs
fromSpher _ = [undefined]

toSpher :: (RealFloat a) => [a] -> [a]
toSpher v = (mag v):(getTheta v):(getPhi v):[]

getPhi :: (RealFloat a) => [a] -> a
getPhi (x:y:_) = atan2 y x
getPhi _ = undefined

getTheta :: (RealFloat a) => [a] -> a
getTheta = ang unitz
