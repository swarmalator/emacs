main = go_command

type Plotpoint = (Integer, Integer, Integer)
type Plot = [Plotpoint]
type Color = (Integer,Integer,Integer)
type Screen = [Color]
type Point = (Float,Float,Float)
type Vector3D = (Float,Float,Float)
type EyeBeam = (Point,Vector3D)

lvl4Plot :: Plot
lvl4Plot = (foldr1(.)$take 3$zipWith($)(repeat(\e a->a>>=(\d(a,b,c)->[(a+d,b,c),(a-d,b,c),(a,b+d,c),(a,b-d,c),(a,b,c+d),(a,b,c-d)])(2^e)))[0..])$[(0,0,0)]

eye_to_screen_dist = 0.31
screen_width = 0.32
screen_height = 0.18
screen_width_pixels = 1280
screen_height_pixels = 720

eye_location :: Point
eye_location = (10.8,14.4,18.0)

eye_direction_central :: Vector3D
eye_direction_central = (-10.0,-13.2,-18.1)

half_block_width = 0.5

xval (x,_,_) = x
yval (_,y,_) = y
zval (_,_,z) = z

beam_initial_x :: EyeBeam -> Float
beam_initial_x ((x,_,_),_) = x
beam_initial_y :: EyeBeam -> Float
beam_initial_y ((_,y,_),_) = y
beam_initial_z :: EyeBeam -> Float
beam_initial_z ((_,_,z),_) = z
beam_step_x :: EyeBeam -> Float
beam_step_x (_,(x,_,_)) = x
beam_step_y :: EyeBeam -> Float
beam_step_y (_,(_,y,_)) = y
beam_step_z :: EyeBeam -> Float
beam_step_z (_,(_,_,z)) = z

top_face_y :: Plotpoint -> Float
top_face_y (_,y,_) = fromInteger y + half_block_width
bottom_face_y :: Plotpoint -> Float
bottom_face_y (_,y,_) = fromInteger y - half_block_width
east_face_x :: Plotpoint -> Float
east_face_x (x,_,_) = fromInteger x + half_block_width
west_face_x :: Plotpoint -> Float
west_face_x (x,_,_) = fromInteger x - half_block_width
south_face_z :: Plotpoint -> Float
south_face_z (_,_,z) = fromInteger z + half_block_width
north_face_z :: Plotpoint -> Float
north_face_z (_,_,z) = fromInteger z - half_block_width

lighten :: Color -> Float -> Color
lighten (r1,g1,b1) n = (r2,g2,b2)
    where r1f = fromInteger r1
          g1f = fromInteger g1
          b1f = fromInteger b1
          r2f = r1f + n * fromInteger (255 - r1)
          g2f = g1f + n * fromInteger (255 - g1)
          b2f = b1f + n * fromInteger (255 - b1)
          r2 = round r2f
          g2 = round g2f
          b2 = round b2f

darken :: Color -> Float -> Color
darken (r1,g1,b1) n = (r2,g2,b2)
    where r1f = fromInteger r1
          g1f = fromInteger g1
          b1f = fromInteger b1
          r2f = r1f - n * fromInteger r1
          g2f = g1f - n * fromInteger g1
          b2f = b1f - n * fromInteger b1
          r2 = round r2f
          g2 = round g2f
          b2 = round b2f

top_hit :: EyeBeam -> Plotpoint -> Maybe (Color,Float)
top_hit le_beam le_block = if inbounds then (if closetoedge then Just(darken (blockcolor le_block) 0.8, numsteps) else Just( darken (blockcolor le_block) 0.5, numsteps)) else Nothing
    where inbounds = (and [north_face_z le_block < z_value_here, z_value_here < south_face_z le_block, west_face_x le_block < x_value_here, x_value_here < east_face_x le_block])
          closetoedge = or [abs (north_face_z le_block - z_value_here) < 0.1, abs (z_value_here - south_face_z le_block) < 0.1, abs (west_face_x le_block - x_value_here) < 0.1, abs (x_value_here - east_face_x le_block) < 0.1]
          numsteps = (top_face_y le_block - beam_initial_y le_beam) / beam_step_y le_beam
          z_value_here = beam_initial_z le_beam + numsteps * beam_step_z le_beam
          x_value_here = beam_initial_x le_beam + numsteps * beam_step_x le_beam

bottom_hit :: EyeBeam -> Plotpoint -> Maybe (Color,Float)
bottom_hit le_beam le_block = if inbounds then (if closetoedge then Just(darken (blockcolor le_block) 0.8, numsteps) else Just(darken (blockcolor le_block) 0.6, numsteps)) else Nothing
    where inbounds = (and [north_face_z le_block < z_value_here, z_value_here < south_face_z le_block, west_face_x le_block < x_value_here, x_value_here < east_face_x le_block])
          closetoedge = or [abs (north_face_z le_block - z_value_here) < 0.1, abs (z_value_here - south_face_z le_block) < 0.1, abs (west_face_x le_block - x_value_here) < 0.1, abs (x_value_here - east_face_x le_block) < 0.1]
          numsteps = (bottom_face_y le_block - beam_initial_y le_beam) / beam_step_y le_beam
          z_value_here = beam_initial_z le_beam + numsteps * beam_step_z le_beam
          x_value_here = beam_initial_x le_beam + numsteps * beam_step_x le_beam

east_hit :: EyeBeam -> Plotpoint -> Maybe (Color,Float)
east_hit le_beam le_block = if inbounds then (if closetoedge then Just(darken (blockcolor le_block) 0.8, numsteps) else Just(lighten (blockcolor le_block) 0.2, numsteps)) else Nothing
    where inbounds = (and [bottom_face_y le_block < y_value_here, y_value_here < top_face_y le_block, north_face_z le_block < z_value_here, z_value_here < south_face_z le_block])
          closetoedge = or [abs (bottom_face_y le_block - y_value_here) < 0.1, abs (y_value_here - top_face_y le_block) < 0.1, abs (north_face_z le_block - z_value_here) < 0.1, abs (z_value_here - south_face_z le_block) < 0.1]
          numsteps = (east_face_x le_block - beam_initial_x le_beam) / beam_step_x le_beam
          y_value_here = beam_initial_y le_beam + numsteps * beam_step_y le_beam
          z_value_here = beam_initial_z le_beam + numsteps * beam_step_z le_beam

west_hit :: EyeBeam -> Plotpoint -> Maybe (Color,Float)
west_hit le_beam le_block = if inbounds then (if closetoedge then Just(darken (blockcolor le_block) 0.8, numsteps) else Just(darken (blockcolor le_block) 0.7, numsteps)) else Nothing
    where inbounds = (and [bottom_face_y le_block < y_value_here, y_value_here < top_face_y le_block, north_face_z le_block < z_value_here, z_value_here < south_face_z le_block])
          closetoedge = or [abs (bottom_face_y le_block - y_value_here) < 0.1, abs ( y_value_here - top_face_y le_block) < 0.1, abs (north_face_z le_block - z_value_here) < 0.1, abs (z_value_here - south_face_z le_block) < 0.1]
          numsteps = (west_face_x le_block - beam_initial_x le_beam) / beam_step_x le_beam
          y_value_here = beam_initial_y le_beam + numsteps * beam_step_y le_beam
          z_value_here = beam_initial_z le_beam + numsteps * beam_step_z le_beam

south_hit :: EyeBeam -> Plotpoint -> Maybe (Color,Float)
south_hit le_beam le_block = if inbounds then (if closetoedge then Just(darken (blockcolor le_block) 0.8, numsteps) else Just(darken (blockcolor le_block) 0.2, numsteps)) else Nothing
    where inbounds = (and [west_face_x le_block < x_value_here, x_value_here < east_face_x le_block, bottom_face_y le_block < y_value_here, y_value_here < top_face_y le_block])
          closetoedge = or [abs (west_face_x le_block - x_value_here) < 0.1, abs (x_value_here - east_face_x le_block) < 0.1, abs (bottom_face_y le_block - y_value_here) < 0.1, abs (y_value_here - top_face_y le_block) < 0.1]
          numsteps = (south_face_z le_block - beam_initial_z le_beam) / beam_step_z le_beam
          x_value_here = beam_initial_x le_beam + numsteps * beam_step_x le_beam
          y_value_here = beam_initial_y le_beam + numsteps * beam_step_y le_beam

north_hit :: EyeBeam -> Plotpoint -> Maybe (Color,Float)
north_hit le_beam le_block = if inbounds then (if closetoedge then Just(darken (blockcolor le_block) 0.8, numsteps) else Just(darken (blockcolor le_block) 1.0, numsteps)) else Nothing
    where inbounds = (and [west_face_x le_block < x_value_here, x_value_here < east_face_x le_block, bottom_face_y le_block < y_value_here, y_value_here < top_face_y le_block])
          closetoedge = or [abs (west_face_x le_block - x_value_here) < 0.1, abs (x_value_here - east_face_x le_block) < 0.1, abs (bottom_face_y le_block - y_value_here) < 0.1, abs (y_value_here - top_face_y le_block) < 0.1]
          numsteps = (north_face_z le_block - beam_initial_z le_beam) / beam_step_z le_beam
          x_value_here = beam_initial_x le_beam + numsteps * beam_step_x le_beam
          y_value_here = beam_initial_y le_beam + numsteps * beam_step_y le_beam

any_hit :: EyeBeam -> Plotpoint -> Maybe (Color,Float)
any_hit le_beam le_block = maybe_closest
    where maybe_color_dist_list = [top_hit le_beam le_block, bottom_hit le_beam le_block, east_hit le_beam le_block, west_hit le_beam le_block, south_hit le_beam le_block, north_hit le_beam le_block]
          maybe_closest = foldl1 foldingfunction maybe_color_dist_list
          foldingfunction (Just x) Nothing = Just x
          foldingfunction Nothing Nothing = Nothing
          foldingfunction Nothing (Just x) = Just x
          foldingfunction (Just x) (Just y) = Just (fun x y)
          fun (c1,d1) (c2,d2) = if d1<d2 then (c1,d1) else (c2,d2)

blockcolor :: Plotpoint -> Color
blockcolor (x,y,z) = boost (fun(128+21*x),fun(128+21*y),fun(128+21*z)) 0.1
    where fun w = if (w<0) then 0 else (if (w>255) then 255 else w)

boost :: Color -> Float-> Color
boost (r1,g1,b1) n = if (r1>g1&&r1>b1) then (r1,round(max(fromInteger(g1)-n*255.0)0),round(max(fromInteger(b1)-n*255.0)0)) else (if (g1>r1&&g1>b1) then (round(max(fromInteger(r1)-n*255.0)0),g1,round(max(fromInteger(b1)-n*255.0)0)) else (if (b1>r1&&b1>g1) then (round(max(fromInteger(r1)-n*255.0)0),round(max(fromInteger(g1)-n*255.0)0),b1) else (r1,g1,b1)))

bgcolor :: EyeBeam -> Color
bgcolor ((_,_,_),(x,y,z)) = (255,255,255)

plot_and_beam_to_color :: Plot -> EyeBeam -> Color
plot_and_beam_to_color le_plot le_beam = if maybe_closest == Nothing then (lighten (bgcolor le_beam) 0.6) else (\(Just (x,_))->x) maybe_closest
    where maybe_color_dist_list = map (any_hit le_beam) le_plot
          maybe_closest = foldl1 foldingfunction maybe_color_dist_list
          foldingfunction (Just x) Nothing = Just x
          foldingfunction Nothing Nothing = Nothing
          foldingfunction Nothing (Just x) = Just x
          foldingfunction (Just x) (Just y) = Just (fun x y)
          fun (c1,d1) (c2,d2) = if d1<d2 then (c1,d1) else (c2,d2)

pixel_coord_matrix :: [(Integer,Integer)]
pixel_coord_matrix = [(u,v) | v <- [1..screen_height_pixels], u <- [1..screen_width_pixels]]

vector_add :: Vector3D -> Vector3D -> Vector3D
vector_add (x1,y1,z1) (x2,y2,z2) = (x1+x2,y1+y2,z1+z2)

scalar_mult :: Float -> Vector3D -> Vector3D
scalar_mult c (x,y,z) = (c*x,c*y,c*z)

normalized :: Vector3D -> Vector3D
normalized le_vector = scalar_mult (1/vector_mag le_vector) le_vector 

screen_center :: Point
screen_center = vector_add (scalar_mult eye_to_screen_dist (normalized eye_direction_central)) eye_location

cross_prod :: Vector3D -> Vector3D -> Vector3D
cross_prod (x1,y1,z1) (x2,y2,z2) = (y1*z2-y2*z1,z1*x2-x1*z2,x1*y2-x2*y1)

vector_mag :: Vector3D -> Float
vector_mag (x,y,z) = sqrt (x**2 + y**2 + z**2)

pixel_coord_to_step :: (Integer, Integer) -> (Float,Float)
pixel_coord_to_step (u_coord, v_coord) = (fromInteger screen_width_pixels / 2.0 - fromInteger u_coord, fromInteger screen_height_pixels / 2.0 - fromInteger v_coord)

pixel_step_matrix :: [(Float,Float)]
pixel_step_matrix = map pixel_coord_to_step pixel_coord_matrix

pixel_steps_to_offset :: (Float,Float) -> Vector3D
pixel_steps_to_offset (u_steps,v_steps) = (u_steps * u_step_length * xval u_unit_vector + v_steps * v_step_length * xval v_unit_vector, u_steps * u_step_length * yval u_unit_vector + v_steps * v_step_length * yval v_unit_vector, u_steps * u_step_length * zval u_unit_vector + v_steps * v_step_length * zval v_unit_vector)
    where u_step_length = screen_width / fromInteger screen_width_pixels
          v_step_length = screen_height / fromInteger screen_height_pixels
          u_vector = cross_prod v_vector w_vector
          v_vector = cross_prod w_vector (0.0,1.0,0.0)
          w_vector = eye_direction_central
          u_unit_vector = normalized u_vector
          v_unit_vector = normalized v_vector
          w_unit_vector = normalized w_vector

pixel_offset_matrix :: [Vector3D]
pixel_offset_matrix = map pixel_steps_to_offset pixel_step_matrix

pixel_location_matrix :: [Point]
pixel_location_matrix = map (vector_add screen_center) pixel_offset_matrix

pixel_location_to_eyebeam :: Point -> EyeBeam
pixel_location_to_eyebeam (pixel_position) = (eye_location, vector_add (scalar_mult (-1.0 :: Float) eye_location) pixel_position)

eyebeam_matrix :: [EyeBeam]
eyebeam_matrix = map pixel_location_to_eyebeam pixel_location_matrix
  
eyebeam_matrix_to_picture :: [EyeBeam] -> Plot -> Screen
eyebeam_matrix_to_picture le_beam_matrix le_plot = map (plot_and_beam_to_color le_plot) le_beam_matrix

this_render :: Screen
this_render = eyebeam_matrix_to_picture eyebeam_matrix lvl4Plot

show_color :: Color -> String
show_color (r,g,b) = show r ++ " " ++ show g ++ " " ++ show b

render_to_PPM :: Screen -> [Char]
render_to_PPM le_render = "P3" ++ "\n" ++ show screen_width_pixels ++ " " ++ show screen_height_pixels ++ "\n" ++ "255" ++ "\n" ++ unlines (map show_color le_render)

this_render_PPM :: String
this_render_PPM = render_to_PPM this_render

go_command :: IO ()
go_command = writeFile "f01.PPM" this_render_PPM
